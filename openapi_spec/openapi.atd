

(* https://spec.openapis.org/oas/v3.1.0#path-templating *)
type path = string wrap <ocaml module="Openapi_path">

(* TODO: Should comply with https://www.rfc-editor.org/rfc/rfc6838 *)
type media = string

(* https://spec.openapis.org/oas/v3.1.0#data-types *)
type int32 = int <ocaml repr="int32">
type int64 = int <ocaml repr="int64">
type float_ = float (* TODO: Validate *)
type double = float
type password = string

type 'a or_ref =
  [ Ref of reference
  | Obj of 'a
  ] <json adapter.ocaml="Adapter.Of_ref">

type reference =
  { ref_ <json name="$ref"> <doc text="REQUIRED. The reference identifier. This MUST be in the form of a URI.">
  : string
  ; ?summary <doc text="A short summary which by default SHOULD override that of the referenced component. If the referenced object-type does not allow a summary field, then this field has no effect.">
  : string option
  ; ?description <doc text="A description which by default SHOULD override that of the referenced component. CommonMark syntax MAY be used for rich text representation. If the referenced object-type does not allow a description field, then this field has no effect.">
  : string option
  }

(* https://spec.openapis.org/oas/v3.1.0#openapi-object *)
type t =
  { openapi : version
  ; info : info
  ; ?servers : server list option
  ; ?paths : paths option
  ; ?jsonSchemaDialect : string option
  ; ?webhooks : webhooks option
  ; ?components : components option
  ; ?security : security option
  ; ?tags : tags option
  ; ?externalDocs : externalDocs option
  }

(* https://spec.openapis.org/oas/v3.1.0#versions *)
type version = string

type json <ocaml module="Yojson.Safe" t="t"> = abstract

type todo <ocaml module="Yojson.Safe" t="t"> = abstract

(* https://spec.openapis.org/oas/v3.1.0#infoObject *)
type info =
  { title <doc text="REQUIRED. The title of the API."> : string
  ; version <doc text="REQUIRED. The version of the OpenAPI document (which is distinct from the OpenAPI Specification version or the API implementation version)."> : string
  ; ?summary <doc text="A short summary of the API."> : string option
  ; ?description <doc text="A description of the API. CommonMark syntax MAY be used for rich text representation."> : string option
  ; ?termsOfService <doc text="A URL to the Terms of Service for the API. This MUST be in the form of a URL."> : string option
  ; ?contact <doc text="The contact information for the exposed API."> : todo option
  ; ?license <doc text="The license information for the exposed API."> : todo option
  }

(* https://spec.openapis.org/oas/v3.1.0#serverObject *)
type server =
  { url : string (* TODO: Should this be something like a path? *)
  ; ?description: string option
  (* TODO: variable values https://spec.openapis.org/oas/v3.1.0#serverVariableObject *)
  ; ?variables: (string * todo) list option <json repr="object">
  }

(* https://spec.openapis.org/oas/v3.1.0#pathsObject *)
type paths = (path * path_item) list <json repr="object">

(* https://spec.openapis.org/oas/v3.1.0#pathItemObject *)
type path_item =
  { ?ref_ <json name="$ref"> : string option
  ; ?summary : string option
  ; ?description : string option
  ; ?get : operation option
  ; ?put : operation option
  ; ?post : operation option
  ; ?delete : operation option
  ; ?options : operation option
  ; ?head : operation option
  ; ?patch : operation option
  ; ?trace : operation option
  ; ?servers : server list option
  ; ?parameters : todo (* [Parameter Object | Reference Object] *) option
  }

(* https://spec.openapis.org/oas/v3.1.0#operationObject *)
type operation =
  { ?tags <doc text="A list of tags for API documentation control. Tags can be used for logical grouping of operations by resources or any other qualifier.">
  : string list option
  ; ?summary <doc text="A short summary of what the operation does.">
  : string option
  ; ?description <doc text="A verbose explanation of the operation behavior. CommonMark syntax MAY be used for rich text representation.">
  : string option
  ; ?externalDocs <doc text="Additional external documentation for this operation.">
  : todo option (* External Documentation Object *)
  ; ?operationId <doc text="Unique string used to identify the operation. The id MUST be unique among all operations described in the API. The operationId value is case-sensitive. Tools and libraries MAY use the operationId to uniquely identify an operation, therefore, it is RECOMMENDED to follow common programming naming conventions.">
  : string option
  ; ?parameters <doc text="A list of parameters that are applicable for this operation. If a parameter is already defined at the Path Item, the new definition will override it but can never remove it. The list MUST NOT include duplicated parameters. A unique parameter is defined by a combination of a name and location. The list can use the Reference Object to link to parameters that are defined at the OpenAPI Object’s components/parameters.">
  : parameter or_ref list option (* [Parameter Object | Reference Object] *)
  ; ?requestBody <doc text="The request body applicable for this operation. The requestBody is fully supported in HTTP methods where the HTTP 1.1 specification [RFC7231] has explicitly defined semantics for request bodies. In other cases where the HTTP spec is vague (such as GET, HEAD and DELETE), requestBody is permitted but does not have well-defined semantics and SHOULD be avoided if possible.">
  : request_body or_ref option  (* Request Body Object | Reference Object *)
  ; ~responses <doc text="The list of possible responses as they are returned from executing this operation.">
  : (string * response) list <json repr="object">  (* Responses Object  *)
  ; ?callbacks <doc text="A map of possible out-of band callbacks related to the parent operation. The key is a unique identifier for the Callback Object. Each value in the map is a Callback Object that describes a request that may be initiated by the API provider and the expected responses.">
  : todo option (* Map[string, Callback Object | Reference Object]  *)
  ; ~deprecated <doc text="Declares this operation to be deprecated. Consumers SHOULD refrain from usage of the declared operation. Default value is false.">
  : bool
  ; ?security <doc text="A declaration of which security mechanisms can be used for this operation. The list of values includes alternative security requirement objects that can be used. Only one of the security requirement objects need to be satisfied to authorize a request. To make security optional, an empty security requirement ({}) can be included in the array. This definition overrides any declared top-level security. To remove a top-level security declaration, an empty array can be used.">
  : todo option (* [Security Requirement Object]  *)
  ; ?servers <doc text="An alternative server array to service this operation. If an alternative server object is specified at the Path Item Object or Root level, it will be overridden by this value.">
  : server list option
  }

(* TODO Compute defaults and validate MUSTs *)
type parameter =
  { name
    <doc text="REQUIRED. The name of the parameter. Parameter names are case sensitive.
              If [in] is \"path\", the name field MUST correspond to a template expression occurring within the path field in the Paths Object. See Path Templating for further information.
              If [in] is \"header\" and the name field is \"Accept\", \"Content-Type\" or \"Authorization\", the parameter definition SHALL be ignored.
              For all other cases, the name corresponds to the parameter name used by the in property.
              ">
    : string
  ; in_ <json name="in">
    <doc text="REQUIRED. The location of the parameter. Possible values are \"query\", \"header\", \"path\" or \"cookie\".">
  : string
  ; ?description
    <doc text="A brief description of the parameter. This could contain examples of use. CommonMark syntax MAY be used for rich text representation.">
  : string option
  ; ~required
    <doc text="Determines whether this parameter is mandatory. If the parameter location is \"path\", this property is REQUIRED and its value MUST be true. Otherwise, the property MAY be included and its default value is false.">
  : bool
  ; ~deprecated
    <doc text="Specifies that a parameter is deprecated and SHOULD be transitioned out of usage. Default value is false.">
  : bool
  ; ~allowEmptyValue
    <doc text="Sets the ability to pass empty-valued parameters. This is valid only for query parameters and allows sending a parameter with an empty value. Default value is false. If style is used, and if behavior is n/a (cannot be serialized), the value of allowEmptyValue SHALL be ignored. Use of this property is NOT RECOMMENDED, as it is likely to be removed in a later revision.">
  : bool
  ; ?style
    <doc text="Describes how the parameter value will be serialized depending on the type of the parameter value. Default values (based on value of in): for query - form; for path - simple; for header - simple; for cookie - form.">
  : string option
  ; ?explode
    <doc text="When this is true, parameter values of type array or object generate separate parameters for each value of the array or key-value pair of the map. For other types of parameters this property has no effect. When style is form, the default value is true. For all other styles, the default value is false.">
  : bool option
  ; ~allowReserved
    <doc text="Determines whether the parameter value SHOULD allow reserved characters, as defined by [RFC3986] :/?#[]@!$&'()*+,;= to be included without percent-encoding. This property only applies to parameters with an in value of query. The default value is false.">
  : bool
  ; ?schema
    <doc text="The schema defining the type used for the parameter.">
  : todo option (* Schema Object *)
  ; ?example
    <doc text="Example of the parameter’s potential value. The example SHOULD match the specified schema and encoding properties if present. The example field is mutually exclusive of the examples field. Furthermore, if referencing a schema that contains an example, the example value SHALL override the example provided by the schema. To represent examples of media types that cannot naturally be represented in JSON or YAML, a string value can contain the example with escaping where necessary.">
  : json option (* Any *)
  ; ?examples
    <doc text="Examples of the parameter’s potential value. Each example SHOULD contain a value in the correct format as specified in the parameter encoding. The examples field is mutually exclusive of the example field. Furthermore, if referencing a schema that contains an example, the examples value SHALL override the example provided by the schema.">
  : todo option (* Map[ string, Example Object | Reference Object] *)
  ; ?content
    <doc text="A map containing the representations for the parameter. The key is the media type and the value describes it. The map MUST only contain one entry.">
  : (string * media_type) list <json repr="object"> option (* Map[string, Media Type Object] *)
  }

(* https://spec.openapis.org/oas/v3.1.0#requestBodyObject *)
type request_body =
  { ?description <doc text="A brief description of the request body. This could contain examples of use. CommonMark syntax MAY be used for rich text representation.">
  : string option
  ; content <doc text="REQUIRED. The content of the request body. The key is a media type or media type range and the value describes it. For requests that match multiple keys, only the most specific key is applicable. e.g. text/plain overrides text/*">
  : (string * media_type) list <json repr="object">
  ; ~required <doc text="Determines if the request body is required in the request. Defaults to false.">
  : bool
  }

(* https://spec.openapis.org/oas/v3.1.0#mediaTypeObject *)
type media_type =
  { ?schema <doc text="The schema defining the content of the request, response, or parameter.">
  : schema option (* Schema Object *)
  ; ?example <doc text="Example of the media type. The example object SHOULD be in the correct format as specified by the media type. The example field is mutually exclusive of the examples field. Furthermore, if referencing a schema which contains an example, the example value SHALL override the example provided by the schema.">
  : json option
  ; ?examples <doc text="Examples of the media type. Each example object SHOULD match the media type and specified schema if present. The examples field is mutually exclusive of the example field. Furthermore, if referencing a schema which contains an example, the examples value SHALL override the example provided by the schema.">
  : todo option (* Map[ string, Example Object | Reference Object] *)
  ; ?encoding <doc text="A map between a property name and its encoding information. The key, being the property name, MUST exist in the schema as a property. The encoding object SHALL only apply to requestBody objects when the media type is multipart or application/x-www-form-urlencoded.">
  : todo option (* Map[string, Encoding Object] *)
  }

type response =
  { description
    <doc text="REQUIRED. A description of the response. CommonMark syntax MAY be used for rich text representation.">
  : string
  ; ?headers
    <doc text="Maps a header name to its definition. [RFC7230] states header names are case insensitive. If a response header is defined with the name \"Content-Type\", it SHALL be ignored.">
  : todo option (* Map[string, Header Object | Reference Object] *)
  ; ?content
    <doc text="A map containing descriptions of potential response payloads. The key is a media type or media type range and the value describes it. For responses that match multiple keys, only the most specific key is applicable. e.g. text/plain overrides text/*">
  : (media * media_type) list <json repr="object"> option  (* Map[string, Media Type Object] *)
  ; ?links
    <doc text="A map of operations links that can be followed from the response. The key of the map is a short name for the link, following the naming constraints of the names for Component Objects.">
  : todo  option (* Map[string, Link Object | Reference Object] *)
  }

(* https://spec.openapis.org/oas/v3.1.0#componentsObject *)
type components =
  { ?schemas : (string * schema) list <json repr="object"> option
  ; ?responses : todo option  (* Map[string, Response Object | Reference Object]  *)
  ; ?parameters : todo option (* Map[string, Parameter Object | Reference Object]  *)
  ; ?examples : todo option (* Map[string, Example Object | Reference Object]  *)
  ; ?requestBodies : todo option (* Map[string, Request Body Object | Reference Object]  *)
  ; ?headers : todo option (* Map[string, Header Object | Reference Object]  *)
  ; ?securitySchemes : todo option (* Map[string, Security Scheme Object | Reference Object]  *)
  ; ?links : todo option (* Map[string, Link Object | Reference Object]  *)
  ; ?callbacks : todo option (* Map[string, Callback Object | Reference Object]  *)
  ; ?pathItems : todo option (* Map[string, Path Item Object | Reference Object]  *)
  }

(* TODO: Once entire spec is loaded, need to feed thes thru Json_data_encoding.Json_schema *)
(* https://spec.openapis.org/oas/v3.1.0#schemaObject *)
type schema = json

(* Map[string, Path Item Object | Reference Object] ] *)
type webhooks = todo

(* https://spec.openapis.org/oas/v3.1.0#securityRequirementObject *)
type security = todo

(* https://spec.openapis.org/oas/v3.1.0#tagObject *)
type tags = todo

(* https://spec.openapis.org/oas/v3.1.0#externalDocumentationObject *)
type externalDocs = todo
